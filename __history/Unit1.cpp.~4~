//---------------------------------------------------------------------------

#include <System.hpp>
#pragma hdrstop

#include "Unit1.h"
#include "Unit2.h"
#include "Unit3.h"
#pragma package(smart_init)
//---------------------------------------------------------------------------
__fastcall ReadThread::ReadThread(bool CreateSuspended)
	: TThread(CreateSuspended)
{
	FreeOnTerminate = true;
	myEvent = new TEvent(NULL, true, false, "", false);
	ProcessThreadPtr = new ProcessThread(myEvent, true);
	ProcessThreadPtr->dataBuffer = dataBuffer;
}
//---------------------------------------------------------------------------
void __fastcall ReadThread::Execute()
{

	using namespace std;

	// Дескриптор файлового устройства (раздела диска).
	HANDLE partition = INVALID_HANDLE_VALUE;
	// Сведения о разделе.
	PARTITION_INFORMATION partitionInfo = {0};
	// Сведения о геометрии диска, на котором расположен раздел.
	DISK_GEOMETRY diskGeometry = {0};

	// Дескриптор файла для сохранения образа раздела.
	HANDLE file = INVALID_HANDLE_VALUE;

	// Буфер для чтения.
	BYTE* buffer = NULL;
	// Размер буфера.
	DWORD bufferSize = 0;

    // Количество возвращенных байт.
	DWORD bytesReturned = 0;
    // Количество записанных байт.
	DWORD bytesWritten = 0;

    // Результат выполнения.
	BOOL result = FALSE;

	wchar_t Path[64];
	UnicodeString EditText = Form2->Edit1->Text;
	wchar_t DiskPath = EditText.w_str()[0];
	swprintf(Path,L"\\\\.\\%c:",DiskPath); //выводит данные в Edit

	// Открываем раздел диска.
	if ((partition = CreateFile(Path,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
        0,
		NULL)) == INVALID_HANDLE_VALUE)
	{
		cout << "Error: " << GetLastError() << endl;
	}

	// Запрашиваем сведения о геометрии диска, на котором расположен раздел.
	if (!DeviceIoControl(partition,
        IOCTL_DISK_GET_DRIVE_GEOMETRY,
        NULL,
		0,
        &diskGeometry,
		sizeof (DISK_GEOMETRY),
		&bytesReturned,
        (LPOVERLAPPED)NULL))
    {
		cout << "Error: " << GetLastError() << endl;
		CloseHandle(partition);
	}

    // Запрашиваем сведения о разделе.
    if (!DeviceIoControl(partition,
		IOCTL_DISK_GET_PARTITION_INFO,
        NULL,
        0,
		&partitionInfo,
		sizeof (PARTITION_INFORMATION),
        &bytesReturned,
        (LPOVERLAPPED)NULL))
    {
        cout << "Error: " << GetLastError() << endl;
		CloseHandle(partition);
    }

    // Размер раздела.
    cout << "Partition's size (in bytes): " << partitionInfo.PartitionLength.QuadPart << endl;
    // Размер диска отличается от размера раздела (причем, может значительно отличаться).
    cout << "Disk's size (in bytes):      " << (diskGeometry.Cylinders.QuadPart) *
		diskGeometry.TracksPerCylinder * diskGeometry.SectorsPerTrack *
        diskGeometry.BytesPerSector << endl;
    cout << "Num of cylinders:    " << diskGeometry.Cylinders.QuadPart << endl;
    cout << "Tracks per cylinder: " << diskGeometry.TracksPerCylinder << endl;
    cout << "Sectors per track:   " << diskGeometry.SectorsPerTrack << endl;
    cout << "Bytes per sector:    " << diskGeometry.BytesPerSector << endl;
	system("PAUSE");

    // Создание файла для сохранения образа.
	if ((file = CreateFileA("D:\\partition.img",
        GENERIC_READ | GENERIC_WRITE,
        0,
		NULL,
        CREATE_ALWAYS,
		0,
		NULL)) == INVALID_HANDLE_VALUE)
    {
        cout << "Error: " << GetLastError() << endl;
        CloseHandle(partition);

    }


    // Резервируем место на диске для сохранения образа раздела. Пока у нас файл 0 байт.
    //
    // Здесь мы передвинем указатель в файле за границу его конца на расстояние равное
	// длине нашего раздела. Тем самым мы увеличили размер файла (но это пока теоретически).
    if (!SetFilePointerEx(file, partitionInfo.PartitionLength, NULL, FILE_BEGIN))
	{
        cout << "Error: " << GetLastError() << endl;
        CloseHandle(file);
		CloseHandle(partition);
    }
    // А вот здесь мы фиксируем новый размер файла физически.
	if (!SetEndOfFile(file))
    {
        cout << "Error: " << GetLastError() << endl;
        CloseHandle(file);
		CloseHandle(partition);
    }


    // Устанавливаем размер буфера.
    bufferSize = diskGeometry.BytesPerSector * diskGeometry.SectorsPerTrack;
    // Выделение памяти для буфера указанного размера.
	buffer = new BYTE[bufferSize];

	// Переменные используемые для отображения процесса копирования.
    int p = 0;
    __int64 s = 0;
	__int64 t = (partitionInfo.PartitionLength.QuadPart / bufferSize) / 100;


    // Устанавливаем указатель на начало файла.
	SetFilePointer(file, 0, NULL, FILE_BEGIN);

    // Копирование раздела в файл.
    do
	{
		// Чтение секторов раздела.
		result = ReadFile(partition, buffer, bufferSize, &bytesReturned, NULL);
        if (!result)
		{
			cout << "Error: " << GetLastError() << endl;
            delete[] buffer;
			CloseHandle(file);
			CloseHandle(partition);
		}

		// Запись секторов в файл образа.
        result = WriteFile(file, buffer, bytesReturned, &bytesWritten, NULL);
		if (!result)
        {
			cout << "Error: " << GetLastError() << endl;
            delete[] buffer;
			CloseHandle(file);
			CloseHandle(partition);
		}

		if (!(s++ % (t)))
		{
			system("CLS");
			cout << "Copied " << p++ << " %" << endl;
		}
	}
	while (result && bytesReturned);

	cout << "Partition copied successfully!\n";

	delete[] buffer;
	CloseHandle(file);
	CloseHandle(partition);

	ProcessThreadPtr->Terminate();
	delete ProcessThreadPtr;
}
//---------------------------------------------------------------------------
